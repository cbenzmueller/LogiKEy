<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>Theory Extended_CJ_DDL (Isabelle2019: June 2019)</title>
<link media="all" rel="stylesheet" type="text/css" href="isabelle.css"/>
</head>

<body>
<div class="head"><h1>Theory Extended_CJ_DDL</h1>

<span class="command">theory</span> <span class="name">Extended_CJ_DDL</span><br/>
<span class="keyword">imports</span> <a href="CJ_DDLplus.html"><span class="name">CJ_DDLplus</span></a><br/>

</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Extended_CJ_DDL</span><span>                    </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*David Fuenmayor and C. Benzm√ºller, 2019*)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>CJ_DDLplus</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">nitpick_params</span></span><span class="delimiter">[</span><span>user_axioms</span><span class="delimiter">=</span><span>true</span><span class="delimiter">,</span><span> </span><span>show_all</span><span class="delimiter">,</span><span> </span><span>expect</span><span class="delimiter">=</span><span>genuine</span><span class="delimiter">,</span><span> </span><span>format</span><span> </span><span class="delimiter">=</span><span> </span><span>3</span><span class="delimiter">]</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Extending the Carmo and Jones DDL Logical Framework&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Context Features&#8250;</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(**To keep things simple (and relevant for our task) we restrict ourselves to representing a context c as the pair: @{text &quot;&#10216;Agent(c), World(c)&#10217;&quot;}.
For this purpose we represent the functional concepts &quot;Agent&quot; and &quot;World&quot; as logical constants.*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">consts</span></span><span> </span><span>Agent</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">&quot;c&#8658;e&quot;</span></span></span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(**function retrieving the agent corresponding to context c*)</span></span></span></span></span><span>   
</span><span class="keyword1"><span class="command">consts</span></span><span> </span><span>World</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">&quot;c&#8658;w&quot;</span></span></span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(**function retrieving the world corresponding to context c*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Logical Validity&#8250;</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(**Kaplan&#39;s notion of (context-dependent) logical truth for a sentence corresponds to its (context-sensitive) formula
(of type @{text &quot;c&#8658;w&#8658;bool&quot;} i.e. m) being true in the given context and at its corresponding world.*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>ldtruectx</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">&quot;m&#8658;c&#8658;bool&quot;</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">&quot;&#8970;_&#8971;<span class="hidden">&#8681;</span><sub>_</sub>&quot;</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8970;&#966;&#8971;<span class="hidden">&#8681;</span><sub>c</sub> &#8801; &#966; c (World c)&quot;</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(**Kaplan&#39;s LD notion of logical validity for a sentence corresponds to its being true in all contexts.
This notion is also known as indexical validity.*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>ldvalid</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">&quot;m&#8658;bool&quot;</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">&quot;&#8970;_&#8971;<span class="hidden">&#8679;</span><sup>D</sup>&quot;</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8970;&#966;&#8971;<span class="hidden">&#8679;</span><sup>D</sup> &#8801; &#8704;c. &#8970;&#966;&#8971;<span class="hidden">&#8681;</span><sub>c</sub>&quot;</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(**Here we show that indexical validity is indeed weaker than its classical modal counterpart (truth at all worlds for all contexts):*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8970;A&#8971; &#10233; &#8970;A&#8971;<span class="hidden">&#8679;</span><sup>D</sup>&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8970;A&#8971;<span class="hidden">&#8679;</span><sup>D</sup> &#10233; &#8970;A&#8971;&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">nitpick</span></span><span> </span><span class="keyword1"><span class="command">oops</span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(**countermodel found*)</span></span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(**Here we show that the interplay between indexical validity and the DDL modal and deontic operators does not
result in modal collapse.*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8970;P <span class="hidden">&#10073;</span><span class="bold">&#8594;</span> <span class="hidden">&#10073;</span><span class="bold">O</span><span class="hidden">&#8681;</span><sub>a</sub>P&#8971;<span class="hidden">&#8679;</span><sup>D</sup>&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">nitpick</span></span><span> </span><span class="keyword1"><span class="command">oops</span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8970;P <span class="hidden">&#10073;</span><span class="bold">&#8594;</span> <span class="hidden">&#10073;</span><span class="bold">&#9633;</span><span class="hidden">&#8681;</span><sub>a</sub>P&#8971;<span class="hidden">&#8679;</span><sup>D</sup>&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">nitpick</span></span><span> </span><span class="keyword1"><span class="command">oops</span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(**Next we show that the necessitation rule does not work for indexical validity (in contrast to classical modal validity as defined for DDL).*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8970;A&#8971;<span class="hidden">&#8679;</span><sup>D</sup> &#10233; &#8970;<span class="hidden">&#10073;</span><span class="bold">&#9633;</span><span class="hidden">&#8681;</span><sub>a</sub>A&#8971;<span class="hidden">&#8679;</span><sup>D</sup>&quot;</span></span></span><span>  </span><span class="keyword1"><span class="command">nitpick</span></span><span> </span><span class="keyword1"><span class="command">oops</span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8970;A&#8971;<span class="hidden">&#8679;</span><sup>D</sup> &#10233; &#8970;<span class="hidden">&#10073;</span><span class="bold">&#9633;</span><span class="hidden">&#8681;</span><sub>p</sub>A&#8971;<span class="hidden">&#8679;</span><sup>D</sup>&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">nitpick</span></span><span> </span><span class="keyword1"><span class="command">oops</span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(**The following operator above is not part of the original Kaplan&#39;s LD and has been added
by us in order to better highlight some semantic features of our formalisation of Gewirth&#39;s argument in the next section and to being able to
use the necessitation rule for some inference steps. This is used to model a kind of logical-indexical necessity in contrast
to the alethic necessity shown above.*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>ldvalidbox</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;m&#8658;m&quot;</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">&quot;<span class="hidden">&#10073;</span><span class="bold">&#9633;</span><span class="hidden">&#8679;</span><sup>D</sup>_&quot;</span></span></span><span> </span><span class="delimiter">[</span><span>52</span><span class="delimiter">]</span><span>53</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;<span class="hidden">&#10073;</span><span class="bold">&#9633;</span><span class="hidden">&#8679;</span><sup>D</sup>&#966; &#8801; &#955;c w. &#8970;&#966;&#8971;<span class="hidden">&#8679;</span><sup>D</sup>&quot;</span></span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(**note the D superscript*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8970;<span class="hidden">&#10073;</span><span class="bold">&#9633;</span><span class="hidden">&#8679;</span><sup>D</sup>&#966;&#8971;<span class="hidden">&#8681;</span><sub>C</sub> &#8801; &#8704;c.&#8970;&#966;&#8971;<span class="hidden">&#8681;</span><sub>c</sub>&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(**works analogously to the box operator in modal logic S5*)</span></span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(**The necessitation rule works for the combination of indexical validity with the previous operator, as intended.*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8970;A&#8971;<span class="hidden">&#8679;</span><sup>D</sup> &#10233; &#8970;<span class="hidden">&#10073;</span><span class="bold">&#9633;</span><span class="hidden">&#8679;</span><sup>D</sup>A&#8971;<span class="hidden">&#8679;</span><sup>D</sup>&quot;</span></span></span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Quantification&#8250;</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(** We also enrich our logic with (higher-order) quantifiers (using parameterized types).*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>mforall</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;t&#8658;m)&#8658;m&quot;</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">&quot;<span class="hidden">&#10073;</span><span class="bold">&#8704;</span>&quot;</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;<span class="hidden">&#10073;</span><span class="bold">&#8704;</span>&#934; &#8801; &#955;c w.&#8704;x. (&#934; x c w)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>mexists</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;t&#8658;m)&#8658;m&quot;</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">&quot;<span class="hidden">&#10073;</span><span class="bold">&#8707;</span>&quot;</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;<span class="hidden">&#10073;</span><span class="bold">&#8707;</span>&#934; &#8801; &#955;c w.&#8707;x. (&#934; x c w)&quot;</span></span></span><span>    
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>mforallBinder</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;t&#8658;m)&#8658;m&quot;</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">binder</span></span><span class="string"><span class="delete"><span class="delete">&quot;<span class="hidden">&#10073;</span><span class="bold">&#8704;</span>&quot;</span></span></span><span class="delimiter">[</span><span>8</span><span class="delimiter">]</span><span>9</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;<span class="hidden">&#10073;</span><span class="bold">&#8704;</span>x. (&#966; x) &#8801; <span class="hidden">&#10073;</span><span class="bold">&#8704;</span>&#966;&quot;</span></span></span><span>  
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>mexistsBinder</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;t&#8658;m)&#8658;m&quot;</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">binder</span></span><span class="string"><span class="delete"><span class="delete">&quot;<span class="hidden">&#10073;</span><span class="bold">&#8707;</span>&quot;</span></span></span><span class="delimiter">[</span><span>8</span><span class="delimiter">]</span><span>9</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;<span class="hidden">&#10073;</span><span class="bold">&#8707;</span>x. (&#966; x) &#8801; <span class="hidden">&#10073;</span><span class="bold">&#8707;</span>&#966;&quot;</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span></pre>

</div>
</body>
</html>
