theory PreferenceLogic imports Main                      
begin 
(*default settings for nitpick model finder*)
nitpick_params[assms=true,user_axioms=true,show_all,expect=genuine,format=3] 

(**** Embedding of "a basic modal preference language" in HOL  ****)

(*Type declarations and type abbreviations*)
typedecl i (*Possible worlds*)  
typedecl e (*Individuals*)      
type_synonym \<sigma> = "i\<Rightarrow>bool" (*World-lifted propositions*)
type_synonym \<mu> = "\<sigma>\<Rightarrow>\<sigma>" (*Unary modal connectives*)
type_synonym \<nu> = "\<sigma>\<Rightarrow>\<sigma>\<Rightarrow>\<sigma>" (*Binary modal connectives*)
type_synonym \<gamma> = "i\<Rightarrow>i\<Rightarrow>bool" (*Preference relations*)
type_synonym \<pi> = "\<sigma>\<Rightarrow>bool" (*Set of world-lefted formulas*)

consts BR::\<gamma> ("_\<preceq>_")  (*Betterness relation*)
abbreviation SBR::\<gamma> ("_\<prec>_")  where  "v\<prec>w \<equiv> (v\<preceq>w) \<and> \<not>(w\<preceq>v)" (*Strict Betterness relation*)

abbreviation reflexive :: "\<gamma>\<Rightarrow>bool" where "reflexive Rel \<equiv> \<forall>x. Rel x x"
abbreviation transitive :: "\<gamma>\<Rightarrow>bool" where "transitive Rel \<equiv> \<forall>x y z. Rel x y \<and> Rel y z \<longrightarrow> Rel x z"
abbreviation total :: "\<gamma>\<Rightarrow>bool" where "total Rel \<equiv> \<forall>x y. Rel x y \<or> Rel y x"
abbreviation irreflexive :: "\<gamma>\<Rightarrow>bool" where "irreflexive Rel \<equiv> \<forall>x. \<not>(Rel x x)"

axiomatization where 
  reflBR:    "reflexive BR"  and 
  transBR: "transitive BR"

lemma "irreflexive SBR" by simp
lemma "transitive SBR" using transBR by blast
lemma "total SBR \<longrightarrow> total BR" by auto

(*Modal logic connectives (operating on truth-sets)*)
abbreviation c1::\<sigma> ("\<^bold>\<bottom>") where "\<^bold>\<bottom> \<equiv> \<lambda>w. False"
abbreviation c2::\<sigma> ("\<^bold>\<top>") where "\<^bold>\<top> \<equiv> \<lambda>w. True"
abbreviation c3::\<mu> ("\<^bold>\<not>_") where "\<^bold>\<not>\<phi> \<equiv> \<lambda>w.\<not>(\<phi> w)"
abbreviation c4::\<nu> ("_\<^bold>\<and>_") where "\<phi>\<^bold>\<and>\<psi> \<equiv> \<lambda>w.(\<phi> w)\<and>(\<psi> w)"   
abbreviation c5::\<nu> ("_\<^bold>\<or>_") where "\<phi>\<^bold>\<or>\<psi> \<equiv> \<lambda>w.(\<phi> w)\<or>(\<psi> w)"
abbreviation c6::\<nu> ("_\<^bold>\<rightarrow>_") where "\<phi>\<^bold>\<rightarrow>\<psi> \<equiv> \<lambda>w.(\<phi> w)\<longrightarrow>(\<psi> w)"  
abbreviation c7::\<nu> ("_\<^bold>\<leftrightarrow>_") where "\<phi>\<^bold>\<leftrightarrow>\<psi> \<equiv> \<lambda>w.(\<phi> w)\<longleftrightarrow>(\<psi> w)"
abbreviation c8::\<mu> ("\<^bold>\<box>\<^sup>\<preceq>_") where "\<^bold>\<box>\<^sup>\<preceq>\<phi> \<equiv> \<lambda>w.\<forall>v.(w\<preceq>v)\<longrightarrow>(\<phi> v)"
abbreviation c9::\<mu> ("\<^bold>\<diamond>\<^sup>\<preceq>_") where "\<^bold>\<diamond>\<^sup>\<preceq>\<phi> \<equiv> \<lambda>w.\<exists>v.(w\<preceq>v)\<and>(\<phi> v)"
abbreviation c10::\<mu> ("\<^bold>\<box>\<^sup>\<prec>_") where "\<^bold>\<box>\<^sup>\<prec>\<phi> \<equiv> \<lambda>w.\<forall>v.(w\<prec>v)\<longrightarrow>(\<phi> v)"
abbreviation c11::\<mu> ("\<^bold>\<diamond>\<^sup>\<prec>_") where "\<^bold>\<diamond>\<^sup>\<prec>\<phi> \<equiv> \<lambda>w.\<exists>v.(w\<prec>v)\<and>(\<phi> v)"
abbreviation c12::\<mu> ("\<^bold>E_") where "\<^bold>E\<phi> \<equiv> \<lambda>w.\<exists>v.(\<phi> v)"  (*Global existence modality*)
abbreviation c13::\<mu> ("\<^bold>A_") where "\<^bold>A\<phi> \<equiv> \<lambda>w.\<forall>v.(\<phi> v)"  (*Global universal modality*)

(*Meta-logical predicate for global validity*)
abbreviation g1::\<pi> ("\<lfloor>_\<rfloor>") where "\<lfloor>\<psi>\<rfloor> \<equiv>  \<forall>w. \<psi> w"

(*Some tests: dualities*)
lemma "\<lfloor>(\<^bold>\<diamond>\<^sup>\<preceq>\<phi>) \<^bold>\<leftrightarrow> (\<^bold>\<not>\<^bold>\<box>\<^sup>\<preceq>\<^bold>\<not>\<phi>)\<rfloor>" by blast
lemma "\<lfloor>(\<^bold>\<diamond>\<^sup>\<prec>\<phi>) \<^bold>\<leftrightarrow> (\<^bold>\<not>\<^bold>\<box>\<^sup>\<prec>\<^bold>\<not>\<phi>)\<rfloor>" by blast
lemma "\<lfloor>(\<^bold>A\<phi>) \<^bold>\<leftrightarrow> (\<^bold>\<not>\<^bold>E\<^bold>\<not>\<phi>)\<rfloor>" by blast

(**** Section 3: A basic modal preference language ****)

(*Definition 5*)
abbreviation leqEE::\<nu> ("_\<preceq>\<^sub>E\<^sub>E_")  where  "(\<phi> \<preceq>\<^sub>E\<^sub>E \<psi>) u \<equiv> \<exists>s. \<exists>t. (\<phi> s) \<and> (\<psi> t) \<and> (s\<preceq>t)" 
abbreviation leqAE::\<nu> ("_\<preceq>\<^sub>A\<^sub>E_")  where  "(\<phi> \<preceq>\<^sub>A\<^sub>E \<psi>) u \<equiv> \<forall>s. \<exists>t. (\<phi> s) \<longrightarrow> (\<psi> t) \<and> (s\<preceq>t)" 
abbreviation leEE::\<nu> ("_\<prec>\<^sub>E\<^sub>E_")   where  "(\<phi> \<prec>\<^sub>E\<^sub>E \<psi>) u \<equiv> \<exists>s. \<exists>t. (\<phi> s) \<and> (\<psi> t) \<and> (s\<prec>t)" 
abbreviation leAE::\<nu> ("_\<prec>\<^sub>A\<^sub>E_")   where  "(\<phi> \<prec>\<^sub>A\<^sub>E \<psi>) u \<equiv> \<forall>s. \<exists>t. (\<phi> s) \<longrightarrow> (\<psi> t) \<and> (s\<prec>t)" 
abbreviation leAA::\<nu> ("_\<prec>\<^sub>A\<^sub>A_")   where  "(\<phi> \<prec>\<^sub>A\<^sub>A \<psi>) u \<equiv> \<forall>s. \<forall>t. (\<phi> s) \<and> (\<psi> t) \<longrightarrow> (s\<prec>t)" 
abbreviation gEA::\<nu> ("_\<succ>\<^sub>E\<^sub>A_")    where  "(\<phi> \<succ>\<^sub>E\<^sub>A \<psi>) u \<equiv> \<exists>s. \<forall>t. (\<phi> s) \<and> (\<psi> t) \<longrightarrow> (t\<prec>s)" 
abbreviation leqAA::\<nu> ("_\<preceq>\<^sub>A\<^sub>A_")  where  "(\<phi> \<preceq>\<^sub>A\<^sub>A \<psi>) u \<equiv> \<forall>s. \<forall>t. (\<phi> s) \<and> (\<psi> t) \<longrightarrow> (s\<preceq>t)" 
abbreviation geqEA::\<nu> ("_\<succeq>\<^sub>E\<^sub>A_")  where  "(\<phi> \<succeq>\<^sub>E\<^sub>A \<psi>) u \<equiv> \<exists>s. \<forall>t. (\<phi> s) \<and> (\<psi> t) \<longrightarrow> (t\<preceq>s)" 


(*Fact 1: definability of the four principal operators and verification*)
abbreviation leqEE'::\<nu> ("_\<^bold>\<preceq>\<^sub>E\<^sub>E_")  where  "\<phi> \<^bold>\<preceq>\<^sub>E\<^sub>E \<psi> \<equiv> \<^bold>E(\<phi> \<^bold>\<and> \<^bold>\<diamond>\<^sup>\<preceq>\<psi>)" 
abbreviation leqAE'::\<nu> ("_\<^bold>\<preceq>\<^sub>A\<^sub>E_")  where  "\<phi> \<^bold>\<preceq>\<^sub>A\<^sub>E \<psi> \<equiv> \<^bold>A(\<phi> \<^bold>\<rightarrow> \<^bold>\<diamond>\<^sup>\<preceq>\<psi>)" 
abbreviation leEE'::\<nu> ("_\<^bold>\<prec>\<^sub>E\<^sub>E_")    where  "\<phi> \<^bold>\<prec>\<^sub>E\<^sub>E \<psi> \<equiv> \<^bold>E(\<phi> \<^bold>\<and> \<^bold>\<diamond>\<^sup>\<prec>\<psi>)" 
abbreviation leAE'::\<nu> ("_\<^bold>\<prec>\<^sub>A\<^sub>E_")    where  "\<phi> \<^bold>\<prec>\<^sub>A\<^sub>E \<psi> \<equiv> \<^bold>A(\<phi> \<^bold>\<rightarrow> \<^bold>\<diamond>\<^sup>\<prec>\<psi>)" 

lemma Fact1_9: "(\<phi> \<^bold>\<preceq>\<^sub>E\<^sub>E \<psi>) u \<longleftrightarrow> (\<phi> \<preceq>\<^sub>E\<^sub>E \<psi>) u" by smt
lemma Fact1_10: "(\<phi> \<^bold>\<preceq>\<^sub>A\<^sub>E \<psi>) u \<longleftrightarrow> (\<phi> \<preceq>\<^sub>A\<^sub>E \<psi>) u" by smt
lemma Fact1_11: "(\<phi> \<^bold>\<prec>\<^sub>E\<^sub>E \<psi>) u \<longleftrightarrow> (\<phi> \<prec>\<^sub>E\<^sub>E \<psi>) u" by smt
lemma Fact1_12: "(\<phi> \<^bold>\<prec>\<^sub>A\<^sub>E \<psi>) u \<longleftrightarrow> (\<phi> \<prec>\<^sub>A\<^sub>E \<psi>) u" by smt

(* Fact 2: definition of the remaining preference operators and verification*)
abbreviation leAA'::\<nu> ("_\<^bold>\<prec>\<^sub>A\<^sub>A_")   where  "\<phi> \<^bold>\<prec>\<^sub>A\<^sub>A \<psi> \<equiv> \<^bold>A(\<psi> \<^bold>\<rightarrow> \<^bold>\<box>\<^sup>\<preceq>\<^bold>\<not>\<phi>)" 
abbreviation gEA'::\<nu> ("_\<^bold>\<succ>\<^sub>E\<^sub>A_")    where  "\<phi> \<^bold>\<succ>\<^sub>E\<^sub>A \<psi> \<equiv> \<^bold>E(\<phi> \<^bold>\<and> \<^bold>\<box>\<^sup>\<preceq>\<^bold>\<not>\<psi>)" 
abbreviation leqAA'::\<nu> ("_\<^bold>\<preceq>\<^sub>A\<^sub>A_")  where  "\<phi> \<^bold>\<preceq>\<^sub>A\<^sub>A \<psi> \<equiv> \<^bold>A(\<phi> \<^bold>\<and> \<^bold>\<box>\<^sup>\<prec>\<^bold>\<not>\<psi>)" 
abbreviation geqEA'::\<nu> ("_\<^bold>\<succeq>\<^sub>E\<^sub>A_")  where  "\<phi> \<^bold>\<succeq>\<^sub>E\<^sub>A \<psi> \<equiv> \<^bold>E(\<phi> \<^bold>\<and> \<^bold>\<box>\<^sup>\<prec>\<^bold>\<not>\<psi>)" 

lemma Fact2_13:    "(\<phi> \<^bold>\<prec>\<^sub>A\<^sub>A \<psi>) u  \<longleftrightarrow> (\<phi> \<prec>\<^sub>A\<^sub>A \<psi>) u"  nitpick oops (*Countermodel*)
lemma Fact2_13_lr: "(\<phi> \<^bold>\<prec>\<^sub>A\<^sub>A \<psi>) u \<longrightarrow> (\<phi> \<prec>\<^sub>A\<^sub>A \<psi>) u" nitpick oops (*Countermodel*)
lemma Fact2_13_rl: "(\<phi> \<prec>\<^sub>A\<^sub>A \<psi>) u \<longrightarrow> (\<phi> \<^bold>\<prec>\<^sub>A\<^sub>A \<psi>) u" by blast
lemma Fact2_13: assumes 1:"total SBR"  shows  "(\<phi> \<^bold>\<prec>\<^sub>A\<^sub>A \<psi>) u \<longleftrightarrow> (\<phi> \<prec>\<^sub>A\<^sub>A \<psi>) u"  by (smt 1) 

lemma Fact2_14:    "(\<phi> \<^bold>\<succ>\<^sub>E\<^sub>A \<psi>) u  \<longleftrightarrow> (\<phi> \<succ>\<^sub>E\<^sub>A \<psi>) u"  nitpick oops (*Countermodel*)
lemma Fact2_14_lr: "(\<phi> \<^bold>\<succ>\<^sub>E\<^sub>A \<psi>) u \<longrightarrow> (\<phi> \<succ>\<^sub>E\<^sub>A \<psi>) u"  nitpick oops (*Countermodel*)
lemma Fact2_14_rl: "(\<phi> \<succ>\<^sub>E\<^sub>A \<psi>) u \<longrightarrow> (\<phi> \<^bold>\<succ>\<^sub>E\<^sub>A \<psi>) u"  nitpick oops (*Countermodel*)
lemma Fact2_14: assumes 1:"total SBR"  shows   "(\<phi> \<^bold>\<succ>\<^sub>E\<^sub>A \<psi>) u \<longleftrightarrow> (\<phi> \<succ>\<^sub>E\<^sub>A \<psi>) u"  by (smt 1)

lemma Fact2_15:    "(\<phi> \<^bold>\<preceq>\<^sub>A\<^sub>A \<psi>) u  \<longleftrightarrow> (\<phi> \<preceq>\<^sub>A\<^sub>A \<psi>) u"  nitpick oops (*Countermodel*)
lemma Fact2_15_lr: "(\<phi> \<^bold>\<preceq>\<^sub>A\<^sub>A \<psi>) u \<longrightarrow> (\<phi> \<preceq>\<^sub>A\<^sub>A \<psi>) u"  nitpick oops (*Countermodel*)
lemma Fact2_15_rl: "(\<phi> \<preceq>\<^sub>A\<^sub>A \<psi>) u \<longrightarrow> (\<phi> \<^bold>\<preceq>\<^sub>A\<^sub>A \<psi>) u"  nitpick oops (*Countermodel*)
lemma Fact2_15: assumes 1:"total SBR"  shows  "(\<phi> \<^bold>\<preceq>\<^sub>A\<^sub>A \<psi>) u \<longleftrightarrow> (\<phi> \<preceq>\<^sub>A\<^sub>A \<psi>) u"  by (smt 1)

lemma Fact2_16:    "(\<phi> \<^bold>\<succeq>\<^sub>E\<^sub>A \<psi>) u  \<longleftrightarrow> (\<phi> \<succeq>\<^sub>E\<^sub>A \<psi>) u"  nitpick oops (*Countermodel*)
lemma Fact2_16_lr: "(\<phi> \<^bold>\<succeq>\<^sub>E\<^sub>A \<psi>) u \<longrightarrow> (\<phi> \<succeq>\<^sub>E\<^sub>A \<psi>) u"  nitpick oops (*Countermodel*)
lemma Fact2_16_rl: "(\<phi> \<succeq>\<^sub>E\<^sub>A \<psi>) u \<longrightarrow> (\<phi> \<^bold>\<succeq>\<^sub>E\<^sub>A \<psi>) u"  nitpick oops (*Countermodel*)
lemma Fact2_16: assumes 1:"total SBR"  shows  "(\<phi> \<^bold>\<succeq>\<^sub>E\<^sub>A \<psi>) u \<longleftrightarrow> (\<phi> \<succeq>\<^sub>E\<^sub>A \<psi>) u"  by (smt 1) 

(* Section 3.5 "Axiomatization" - verify interaction axioms *)
lemma Inclusion_1:      "\<lfloor>(\<^bold>\<diamond>\<^sup>\<prec>\<phi>) \<^bold>\<rightarrow> (\<^bold>\<diamond>\<^sup>\<preceq>\<phi>)\<rfloor>" by auto
lemma Interaction_1:    "\<lfloor>(\<^bold>\<diamond>\<^sup>\<preceq>\<^bold>\<diamond>\<^sup>\<prec>\<phi>) \<^bold>\<rightarrow> (\<^bold>\<diamond>\<^sup>\<prec>\<phi>)\<rfloor>" using transBR by blast
lemma Transitivity_le:  "\<lfloor>(\<^bold>\<diamond>\<^sup>\<prec>\<^bold>\<diamond>\<^sup>\<prec>\<phi>) \<^bold>\<rightarrow> (\<^bold>\<diamond>\<^sup>\<prec>\<phi>)\<rfloor>" using transBR by blast 
lemma Interaction_2:    "\<lfloor>(\<phi> \<^bold>\<and> \<^bold>\<diamond>\<^sup>\<preceq>\<psi>) \<^bold>\<rightarrow>  ((\<^bold>\<diamond>\<^sup>\<prec>\<psi>) \<^bold>\<or> \<^bold>\<diamond>\<^sup>\<preceq>(\<psi> \<^bold>\<and>  \<^bold>\<diamond>\<^sup>\<preceq>\<phi>))\<rfloor>" by blast
lemma Fact4:               "\<lfloor>(\<phi> \<^bold>\<and> \<^bold>\<diamond>\<^sup>\<preceq>\<psi>) \<^bold>\<rightarrow>  ((\<^bold>\<diamond>\<^sup>\<prec>\<psi>) \<^bold>\<or> \<^bold>\<diamond>\<^sup>\<preceq>(\<psi> \<^bold>\<and>  \<^bold>\<diamond>\<^sup>\<preceq>\<phi>))\<rfloor> 
                                      \<longleftrightarrow> (\<forall>w. \<forall>v. (((w \<preceq> v) \<and> \<not>(v \<preceq> w)) \<longrightarrow> (w \<prec> v)))"   by smt
lemma Interaction_3:   "\<lfloor>(\<^bold>\<diamond>\<^sup>\<prec>\<^bold>\<diamond>\<^sup>\<preceq>\<phi>) \<^bold>\<rightarrow> (\<^bold>\<diamond>\<^sup>\<prec>\<phi>)\<rfloor>" using transBR by blast
lemma Inclusion_2:      "\<lfloor>(\<^bold>\<diamond>\<^sup>\<preceq>\<phi>) \<^bold>\<rightarrow> (\<^bold>E\<phi>)\<rfloor>"  by blast

(* Section 3.6 "A binary preference fragment" *)

(* \<^bold>\<preceq>\<^sub>E\<^sub>E is the dual of \<^bold>\<prec>\<^sub>A\<^sub>A *)
lemma "\<lfloor>(\<phi> \<^bold>\<preceq>\<^sub>E\<^sub>E \<psi>) \<^bold>\<leftrightarrow> \<^bold>\<not>(\<psi> \<^bold>\<prec>\<^sub>A\<^sub>A \<phi>)\<rfloor>" by blast
lemma "\<lfloor>(\<phi> \<^bold>\<prec>\<^sub>A\<^sub>A \<psi>) \<^bold>\<leftrightarrow> \<^bold>\<not>(\<psi> \<^bold>\<preceq>\<^sub>E\<^sub>E \<phi>)\<rfloor>" by simp

(* \<preceq>\<^sub>E\<^sub>E is the dual of \<prec>\<^sub>A\<^sub>A only if totality is assumed*)
lemma "\<lfloor>(\<phi> \<preceq>\<^sub>E\<^sub>E \<psi>) \<^bold>\<leftrightarrow> \<^bold>\<not>(\<psi> \<prec>\<^sub>A\<^sub>A \<phi>)\<rfloor>" nitpick oops (*countermodel*)
lemma "\<lfloor>(\<phi> \<preceq>\<^sub>E\<^sub>E \<psi>) \<^bold>\<rightarrow> \<^bold>\<not>(\<psi> \<prec>\<^sub>A\<^sub>A \<phi>)\<rfloor>" by blast (* only this direction holds*)
lemma "total SBR \<longrightarrow> \<lfloor>(\<phi> \<preceq>\<^sub>E\<^sub>E \<psi>) \<^bold>\<leftrightarrow> \<^bold>\<not>(\<psi> \<prec>\<^sub>A\<^sub>A \<phi>)\<rfloor>" by blast

lemma "\<lfloor>(\<phi> \<prec>\<^sub>A\<^sub>A \<psi>) \<^bold>\<leftrightarrow> \<^bold>\<not>(\<psi> \<preceq>\<^sub>E\<^sub>E \<phi>)\<rfloor>" nitpick oops
lemma "\<lfloor>(\<phi> \<prec>\<^sub>A\<^sub>A \<psi>) \<^bold>\<rightarrow> \<^bold>\<not>(\<psi> \<preceq>\<^sub>E\<^sub>E \<phi>)\<rfloor>" by blast (* only this direction holds*)
lemma "total SBR \<longrightarrow> \<lfloor>(\<phi> \<prec>\<^sub>A\<^sub>A \<psi>) \<^bold>\<leftrightarrow> \<^bold>\<not>(\<psi> \<preceq>\<^sub>E\<^sub>E \<phi>)\<rfloor>" by blast

(* verify p.97-98 *)
lemma monotonicity:  "\<lfloor>((\<phi> \<preceq>\<^sub>E\<^sub>E \<psi>) \<^bold>\<and> \<^bold>A(\<phi>\<^bold>\<rightarrow>\<xi>)) \<^bold>\<rightarrow> (\<xi> \<preceq>\<^sub>E\<^sub>E \<psi>)\<rfloor>" by blast
lemma reducibility:     "\<lfloor>(((\<phi> \<preceq>\<^sub>E\<^sub>E \<psi>) \<^bold>\<and> \<alpha>) \<preceq>\<^sub>E\<^sub>E \<beta>) \<^bold>\<leftrightarrow> ((\<phi> \<preceq>\<^sub>E\<^sub>E \<psi>) \<^bold>\<and> (\<alpha> \<preceq>\<^sub>E\<^sub>E \<beta>))\<rfloor>" by blast
lemma reflexivity:      "\<lfloor>\<phi> \<^bold>\<rightarrow> (\<phi> \<preceq>\<^sub>E\<^sub>E \<phi>)\<rfloor>" using reflBR by blast

(* The condition below is supposed to enforce totality of the preference relation.
 However there are countermodels. See p.98 *)
lemma totality_v1: "total SBR \<longrightarrow> \<lfloor>((\<phi> \<preceq>\<^sub>E\<^sub>E \<phi>) \<^bold>\<and> (\<psi> \<preceq>\<^sub>E\<^sub>E \<psi>)) \<^bold>\<rightarrow> ((\<phi> \<preceq>\<^sub>E\<^sub>E \<psi>) \<^bold>\<or> (\<psi> \<preceq>\<^sub>E\<^sub>E \<phi>))\<rfloor>" by auto
lemma "\<lfloor>((\<phi> \<preceq>\<^sub>E\<^sub>E \<phi>) \<^bold>\<and> (\<psi> \<preceq>\<^sub>E\<^sub>E \<psi>)) \<^bold>\<rightarrow> ((\<phi> \<preceq>\<^sub>E\<^sub>E \<psi>) \<^bold>\<or> (\<psi> \<preceq>\<^sub>E\<^sub>E \<phi>))\<rfloor> \<longrightarrow> total SBR" 
  nitpick oops (*countermodel - error in paper?*)
lemma totality_v2: "total SBR \<longrightarrow> \<lfloor>((\<phi> \<^bold>\<preceq>\<^sub>E\<^sub>E \<phi>) \<^bold>\<and> (\<psi> \<^bold>\<preceq>\<^sub>E\<^sub>E \<psi>)) \<^bold>\<rightarrow> ((\<phi> \<^bold>\<preceq>\<^sub>E\<^sub>E \<psi>) \<^bold>\<or> (\<psi> \<^bold>\<preceq>\<^sub>E\<^sub>E \<phi>))\<rfloor>" by auto
lemma "\<lfloor>((\<phi> \<^bold>\<preceq>\<^sub>E\<^sub>E \<phi>) \<^bold>\<and> (\<psi> \<^bold>\<preceq>\<^sub>E\<^sub>E \<psi>)) \<^bold>\<rightarrow> ((\<phi> \<^bold>\<preceq>\<^sub>E\<^sub>E \<psi>) \<^bold>\<or> (\<psi> \<^bold>\<preceq>\<^sub>E\<^sub>E \<phi>))\<rfloor> \<longrightarrow> total SBR"
  nitpick oops (*countermodel - error in paper?*)

(**** Section 5: Equality-based Ceteris Paribus Preference Logic ****)
abbreviation elem::"\<sigma>\<Rightarrow>\<pi>\<Rightarrow>bool" ("_\<^bold>\<in>_")  where  "\<phi> \<^bold>\<in> \<Gamma> \<equiv> \<Gamma> \<phi>" 
abbreviation subseteq::"\<pi>\<Rightarrow>\<pi>\<Rightarrow>bool" ("_\<^bold>\<subseteq>_")  where  "\<Gamma> \<^bold>\<subseteq> \<Gamma>' \<equiv> \<forall>\<phi>. \<phi> \<^bold>\<in> \<Gamma> \<longrightarrow> \<phi> \<^bold>\<in> \<Gamma>'" 
abbreviation union::"\<pi>\<Rightarrow>\<pi>\<Rightarrow>\<pi>" ("_\<^bold>\<union>_")  where  "\<Gamma> \<^bold>\<union> \<Gamma>' \<equiv> \<lambda>\<phi>. \<phi> \<^bold>\<in> \<Gamma> \<or> \<phi> \<^bold>\<in> \<Gamma>'" 
abbreviation mkSet::"\<sigma>\<Rightarrow>\<pi>" ("\<^bold>{_\<^bold>}")  where  "\<^bold>{\<phi>\<^bold>} \<equiv> \<lambda>x. x=\<phi>" 
abbreviation emptySet ("\<^bold>\<emptyset>") where "\<^bold>\<emptyset> \<equiv> (\<lambda> \<psi>. False)"

abbreviation c14::"i\<Rightarrow>\<pi>\<Rightarrow>i\<Rightarrow>bool" ("_ \<^bold>\<equiv>\<^sub>_ _") where "w \<^bold>\<equiv>\<^sub>\<Gamma> v \<equiv> \<forall>\<phi>. (\<phi> \<^bold>\<in> \<Gamma>) \<longrightarrow> ((\<phi> w) \<longleftrightarrow> (\<phi> v))"
abbreviation c15::"i\<Rightarrow>\<pi>\<Rightarrow>i\<Rightarrow>bool" ("_ \<^bold>\<unlhd>\<^sub>_ _") where "w \<^bold>\<unlhd>\<^sub>\<Gamma> v \<equiv>  (w \<preceq> v) \<and> (w \<^bold>\<equiv>\<^sub>\<Gamma> v)"
abbreviation c16::"i\<Rightarrow>\<pi>\<Rightarrow>i\<Rightarrow>bool" ("_ \<^bold>\<lhd>\<^sub>_ _") where "w \<^bold>\<lhd>\<^sub>\<Gamma> v \<equiv>  (w \<prec> v) \<and> (w \<^bold>\<equiv>\<^sub>\<Gamma> v)"
abbreviation c17::"\<pi>\<Rightarrow>\<sigma>\<Rightarrow>\<sigma>" ("\<^bold>\<langle>_\<^bold>\<rangle>\<^sup>\<preceq>_") where "\<^bold>\<langle>\<Gamma>\<^bold>\<rangle>\<^sup>\<preceq>\<phi> \<equiv> \<lambda>w.\<exists>v. (w \<^bold>\<unlhd>\<^sub>\<Gamma> v) \<and> (\<phi> v)"
abbreviation c18::"\<pi>\<Rightarrow>\<sigma>\<Rightarrow>\<sigma>" ("[_]\<^sup>\<preceq>_") where "[\<Gamma>]\<^sup>\<preceq>\<phi> \<equiv> \<lambda>w.\<forall>v. (w \<^bold>\<unlhd>\<^sub>\<Gamma> v) \<longrightarrow> (\<phi> v)"
abbreviation c19::"\<pi>\<Rightarrow>\<sigma>\<Rightarrow>\<sigma>" ("\<^bold>\<langle>_\<^bold>\<rangle>\<^sup>\<prec>_") where "\<^bold>\<langle>\<Gamma>\<^bold>\<rangle>\<^sup>\<prec>\<phi> \<equiv> \<lambda>w.\<exists>v. (w \<^bold>\<lhd>\<^sub>\<Gamma> v) \<and> (\<phi> v)"
abbreviation c20::"\<pi>\<Rightarrow>\<sigma>\<Rightarrow>\<sigma>" ("[_]\<^sup>\<prec>_") where "[\<Gamma>]\<^sup>\<prec>\<phi> \<equiv> \<lambda>w.\<forall>v. (w \<^bold>\<lhd>\<^sub>\<Gamma> v) \<longrightarrow> (\<phi> v)"
abbreviation c21::"\<pi>\<Rightarrow>\<sigma>\<Rightarrow>\<sigma>" ("\<^bold>\<langle>_\<^bold>\<rangle>_") where "\<^bold>\<langle>\<Gamma>\<^bold>\<rangle>\<phi> \<equiv> \<lambda>w.\<exists>v. (w \<^bold>\<equiv>\<^sub>\<Gamma> v) \<and> (\<phi> v)"
abbreviation c22::"\<pi>\<Rightarrow>\<sigma>\<Rightarrow>\<sigma>" ("[_]_") where "[\<Gamma>]\<phi> \<equiv> \<lambda>w.\<forall>v. (w \<^bold>\<equiv>\<^sub>\<Gamma> v) \<longrightarrow> (\<phi> v)"

(*Some tests: dualities*)
lemma "\<lfloor>(\<^bold>\<langle>\<Gamma>\<^bold>\<rangle>\<^sup>\<preceq>\<phi>) \<^bold>\<leftrightarrow> \<^bold>\<not>([\<Gamma>]\<^sup>\<preceq>\<^bold>\<not>\<phi>)\<rfloor>"  by auto
lemma "\<lfloor>(\<^bold>\<langle>\<Gamma>\<^bold>\<rangle>\<^sup>\<prec>\<phi>) \<^bold>\<leftrightarrow> \<^bold>\<not>([\<Gamma>]\<^sup>\<prec>\<^bold>\<not>\<phi>)\<rfloor>"  by auto
lemma "\<lfloor>(\<^bold>\<langle>\<Gamma>\<^bold>\<rangle>\<phi>) \<^bold>\<leftrightarrow> \<^bold>\<not>([\<Gamma>]\<^bold>\<not>\<phi>)\<rfloor>"  by auto

(*Lemma 2*)
lemma lemma2_1: "(\<^bold>\<diamond>\<^sup>\<preceq>\<phi>) w \<longleftrightarrow> (\<^bold>\<langle>\<^bold>\<emptyset>\<^bold>\<rangle>\<^sup>\<preceq>\<phi>) w" by auto
lemma lemma2_2: "(\<^bold>\<diamond>\<^sup>\<prec>\<phi>) w \<longleftrightarrow> (\<^bold>\<langle>\<^bold>\<emptyset>\<^bold>\<rangle>\<^sup>\<prec>\<phi>) w" by auto  
lemma lemma2_3: "(\<^bold>E\<phi>) w \<longleftrightarrow> (\<^bold>\<langle>\<^bold>\<emptyset>\<^bold>\<rangle>\<phi>) w" by auto

(*Axiomatization:*)
(*inclusion and interaction axioms *)
lemma Inc1: "\<lfloor>(\<^bold>\<langle>\<Gamma>\<^bold>\<rangle>\<^sup>\<prec>\<phi>) \<^bold>\<rightarrow> (\<^bold>\<langle>\<Gamma>\<^bold>\<rangle>\<^sup>\<preceq>\<phi>)\<rfloor>" by auto
lemma Inc2: "\<lfloor>(\<^bold>\<langle>\<Gamma>\<^bold>\<rangle>\<^sup>\<preceq>\<phi>) \<^bold>\<rightarrow> (\<^bold>\<langle>\<Gamma>\<^bold>\<rangle>\<phi>)\<rfloor>" by auto
lemma Int3:  "\<lfloor>(\<^bold>\<langle>\<Gamma>\<^bold>\<rangle>\<^sup>\<preceq>(\<^bold>\<langle>\<Gamma>\<^bold>\<rangle>\<^sup>\<preceq>\<phi>)) \<^bold>\<rightarrow>(\<^bold>\<langle>\<Gamma>\<^bold>\<rangle>\<^sup>\<preceq>\<phi>)\<rfloor>" by (meson transBR) 
lemma Int4:  "\<lfloor>(\<^bold>\<langle>\<Gamma>\<^bold>\<rangle>\<^sup>\<prec>(\<^bold>\<langle>\<Gamma>\<^bold>\<rangle>\<^sup>\<preceq>\<phi>)) \<^bold>\<rightarrow>(\<^bold>\<langle>\<Gamma>\<^bold>\<rangle>\<^sup>\<prec>\<phi>)\<rfloor>" by (metis transBR)
lemma Int5:  "\<lfloor>(\<psi> \<^bold>\<and> (\<^bold>\<langle>\<Gamma>\<^bold>\<rangle>\<^sup>\<preceq>\<phi>)) \<^bold>\<rightarrow> ( (\<^bold>\<langle>\<Gamma>\<^bold>\<rangle>\<^sup>\<prec>\<phi>) \<^bold>\<or> (\<^bold>\<langle>\<Gamma>\<^bold>\<rangle>\<^sup>\<preceq>(\<phi> \<^bold>\<and> (\<^bold>\<langle>\<Gamma>\<^bold>\<rangle>\<^sup>\<preceq>\<phi>))))\<rfloor>" using reflBR by fastforce
(*ceteris paribus reflexivity*)
lemma CetPar6:   assumes 1:"\<phi> \<^bold>\<in> \<Gamma>"   shows  "\<lfloor>(\<^bold>\<langle>\<Gamma>\<^bold>\<rangle>\<phi>) \<^bold>\<rightarrow> \<phi>\<rfloor>"  using 1 by blast 
lemma CetPar7:   assumes 1:"\<phi> \<^bold>\<in> \<Gamma>"   shows  "\<lfloor>(\<^bold>\<langle>\<Gamma>\<^bold>\<rangle>\<^bold>\<not>\<phi>) \<^bold>\<rightarrow> \<^bold>\<not>\<phi>\<rfloor>"  using 1 by blast 
(*monotonicity*)
lemma CetPar8:   assumes 1:"\<Gamma> \<^bold>\<subseteq> \<Gamma>' " shows  "\<lfloor>(\<^bold>\<langle>\<Gamma>'\<^bold>\<rangle>\<phi>) \<^bold>\<rightarrow> (\<^bold>\<langle>\<Gamma>\<^bold>\<rangle>\<phi>)\<rfloor>"  using 1 by auto
lemma CetPar9:   assumes 1:"\<Gamma> \<^bold>\<subseteq> \<Gamma>' " shows  "\<lfloor>(\<^bold>\<langle>\<Gamma>'\<^bold>\<rangle>\<^sup>\<preceq>\<phi>) \<^bold>\<rightarrow> (\<^bold>\<langle>\<Gamma>\<^bold>\<rangle>\<^sup>\<preceq>\<phi>)\<rfloor>"  using 1 by auto
lemma CetPar10: assumes 1:"\<Gamma> \<^bold>\<subseteq> \<Gamma>' " shows  "\<lfloor>(\<^bold>\<langle>\<Gamma>'\<^bold>\<rangle>\<^sup>\<prec>\<phi>) \<^bold>\<rightarrow> (\<^bold>\<langle>\<Gamma>\<^bold>\<rangle>\<^sup>\<prec>\<phi>)\<rfloor>"  using 1 by auto
(*increase (decrease) of ceteris paribus sets*)
lemma CetPar11a: "\<lfloor>(\<phi> \<^bold>\<and> (\<^bold>\<langle>\<Gamma>\<^bold>\<rangle>(\<alpha> \<^bold>\<and> \<phi>) )) \<^bold>\<rightarrow> (\<^bold>\<langle>\<Gamma>\<^bold>\<union>\<^bold>{\<phi>\<^bold>}\<^bold>\<rangle>\<alpha>)\<rfloor>" by auto 
lemma CetPar11b: "\<lfloor>((\<^bold>\<not>\<phi>) \<^bold>\<and> (\<^bold>\<langle>\<Gamma>\<^bold>\<rangle>(\<alpha> \<^bold>\<and> \<^bold>\<not>\<phi>))) \<^bold>\<rightarrow> (\<^bold>\<langle>\<Gamma>\<^bold>\<union>\<^bold>{\<phi>\<^bold>}\<^bold>\<rangle>\<alpha>)\<rfloor>" by auto 
lemma CetPar12a: "\<lfloor>(\<phi> \<^bold>\<and> (\<^bold>\<langle>\<Gamma>\<^bold>\<rangle>\<^sup>\<preceq>(\<alpha> \<^bold>\<and> \<phi>) )) \<^bold>\<rightarrow> (\<^bold>\<langle>\<Gamma>\<^bold>\<union>\<^bold>{\<phi>\<^bold>}\<^bold>\<rangle>\<^sup>\<preceq>\<alpha>)\<rfloor>" by auto 
lemma CetPar12b: "\<lfloor>((\<^bold>\<not>\<phi>) \<^bold>\<and> (\<^bold>\<langle>\<Gamma>\<^bold>\<rangle>\<^sup>\<preceq>(\<alpha> \<^bold>\<and> \<^bold>\<not>\<phi>))) \<^bold>\<rightarrow> (\<^bold>\<langle>\<Gamma>\<^bold>\<union>\<^bold>{\<phi>\<^bold>}\<^bold>\<rangle>\<^sup>\<preceq>\<alpha>)\<rfloor>" by auto 
lemma CetPar13a: "\<lfloor>(\<phi> \<^bold>\<and> (\<^bold>\<langle>\<Gamma>\<^bold>\<rangle>\<^sup>\<prec>(\<alpha> \<^bold>\<and> \<phi>) )) \<^bold>\<rightarrow> (\<^bold>\<langle>\<Gamma>\<^bold>\<union>\<^bold>{\<phi>\<^bold>}\<^bold>\<rangle>\<^sup>\<prec>\<alpha>)\<rfloor>" by auto 
lemma CetPar13b: "\<lfloor>((\<^bold>\<not>\<phi>) \<^bold>\<and> (\<^bold>\<langle>\<Gamma>\<^bold>\<rangle>\<^sup>\<prec>(\<alpha> \<^bold>\<and> \<^bold>\<not>\<phi>))) \<^bold>\<rightarrow> (\<^bold>\<langle>\<Gamma>\<^bold>\<union>\<^bold>{\<phi>\<^bold>}\<^bold>\<rangle>\<^sup>\<prec>\<alpha>)\<rfloor>" by auto 

(*Example 1*)
lemma Example1: "\<lfloor>(([\<Gamma>]\<^sup>\<preceq>\<phi>) \<^bold>\<and> (\<^bold>\<langle>\<Gamma>\<^bold>\<rangle>\<^sup>\<preceq>\<alpha>)) \<^bold>\<rightarrow> (\<^bold>\<langle>\<Gamma>\<^bold>\<union>\<^bold>{\<phi>\<^bold>}\<^bold>\<rangle>\<^sup>\<preceq>\<alpha>)\<rfloor>" using reflBR by auto

(*Lemma 4: Existence Lemma*)
lemma Lemma4: "(\<^bold>\<langle>\<Gamma>\<^bold>\<rangle>\<^sup>\<preceq>\<phi>) w \<longrightarrow> (\<exists>v. (w \<^bold>\<unlhd>\<^sub>\<Gamma> v) \<and> (\<phi> v))"  by simp 

(*Corollary 1*)
lemma Corollary1: "(\<^bold>\<langle>\<Gamma>\<^bold>\<rangle>\<phi>) w \<longrightarrow> (\<exists>v. (w \<^bold>\<equiv>\<^sub>\<Gamma> v) \<and> (\<phi> v))"  by simp 

(*Lemma 5*)
lemma Lemma5: "w \<^bold>\<unlhd>\<^sub>\<Gamma> v \<longleftrightarrow> ((w \<preceq> v) \<and> (w \<^bold>\<equiv>\<^sub>\<Gamma> v))" by auto  


(***** proof of concept formalization*****)

(*values*)
consts EFFI :: \<sigma> GAIN :: \<sigma>
consts STAB :: \<sigma> RELI :: \<sigma> 
consts WILL :: \<sigma> RESP :: \<sigma>
consts EQUI :: \<sigma> FAIR :: \<sigma>
(*TODO: encode dialectical relations between values*)

(*kinds of situations*)
consts WildAnimals :: \<sigma>  (*appropriation of wild animals*)
consts DomesticAnimals :: \<sigma> (*appropriation of domestic animals*)
(*...*)

axiomatization where
ax_1: "\<lfloor>WildAnimals \<^bold>\<rightarrow>  (STAB  \<^bold>\<preceq>\<^sub>A\<^sub>A  WILL)\<rfloor>" and
ax_2: "\<lfloor>DomesticAnimals \<^bold>\<rightarrow>  ((RELI \<^bold>\<and> WILL)  \<^bold>\<preceq>\<^sub>A\<^sub>A  STAB)\<rfloor>"
(*...*)

(*TODO: find an use to ceteris paribus preferences*)

end


